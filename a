/* FILE NAME   : mth_matr.h
 * PROGRAMMER  : AG2
 * LAST UPDATE : 22.07.2023
 * PURPOSE     : Ray Tressing project.
 *               Math module.
 *               3D math matrix implementation module.
 */

#ifndef __mth_matr_h_
#define __mth_matr_h_

#include "mth_def.h"

/* Pi math constant */
#define PI 3.14159265358979323846

/* Degrees to radians conversion */
#define D2R(A) ((A) * (PI / 180.0))
#define Degree2Radian(a) D2R(a)

/* Radians to degrees conversion */
#define R2D(A) ((A) * (180.0 / PI))
#define Radian2Degree(a) R2D(a)

/* Space math namespace */
namespace mth
{
  /* Matrix representation type */
  template<typename Type>
    class matr
    {
    private:
      Type A[4][4]; // Matrix elements
     
    public:
      /* Matrix default constructor */
      matr( void )
      {
      }
      /* Matrix constructor by 16 elements */
      matr( Type &A00, Type &A01, Type &A02, Type &A03,
            Type &A10, Type &A11, Type &A12, Type &A13,
            Type &A20, Type &A21, Type &A22, Type &A23,
            Type &A30, Type &A31, Type &A32, Type &A33 )
      {
        A[0][0] = A00;
        A[0][1] = A01;
        A[0][2] = A02;
        A[0][3] = A03;
        A[1][0] = A10;
        A[1][1] = A11;
        A[1][2] = A12;
        A[1][3] = A13;
        A[2][0] = A20;
        A[2][1] = A21;
        A[2][2] = A22;
        A[2][3] = A23;
        A[3][0] = A30;
        A[3][1] = A31;
        A[3][2] = A32;
        A[3][3] = A33;
      }
      /* Matrix constructor by array */
      matr( Type a[4][4] )
      {
        A[0][0] = a[0][0];
        A[0][1] = a[0][1];
        A[0][2] = a[0][2];
        A[0][3] = a[0][3];
        A[1][0] = a[1][0];
        A[1][1] = a[1][1];
        A[1][2] = a[1][2];
        A[1][3] = a[1][3];
        A[2][0] = a[2][0];
        A[2][1] = a[2][1];
        A[2][2] = a[2][2];
        A[2][3] = a[2][3];
        A[3][0] = a[3][0];
        A[3][1] = a[3][1];
        A[3][2] = a[3][2];
        A[3][3] = a[3][3];
      }

      /*** Overload operations ***/
      
      /* Multiply two matrixes function.
       * ARGUMENTS:
       *   - reference to second matrix:
       *       matr &A;
       * RETURNS: 
       *   (matr) result new matrix.
       */
      matr operator*( const matr &M ) const
      {
        return matr( 
          A[0][0] * M[0][0] + A[0][1] * M[1][0] + A[0][2] * M[2][0] + A[0][3] * M[3][0],
          A[0][0] * M[0][1] + A[0][1] * M[1][1] + A[0][2] * M[2][1] + A[0][3] * M[3][1],
          A[0][0] * M[0][2] + A[0][1] * M[1][2] + A[0][2] * M[2][2] + A[0][3] * M[3][2],
          A[0][0] * M[0][3] + A[0][1] * M[1][3] + A[0][2] * M[2][3] + A[0][3] * M[3][3],

          A[1][0] * M[0][0] + A[1][1] * M[1][0] + A[1][2] * M[2][0] + A[1][3] * M[3][0],
          A[1][0] * M[0][1] + A[1][1] * M[1][1] + A[1][2] * M[2][1] + A[1][3] * M[3][1],
          A[1][0] * M[0][2] + A[1][1] * M[1][2] + A[1][2] * M[2][2] + A[1][3] * M[3][2],
          A[1][0] * M[0][3] + A[1][1] * M[1][3] + A[1][2] * M[2][3] + A[1][3] * M[3][3],

          A[2][0] * M[0][0] + A[2][1] * M[1][0] + A[2][2] * M[2][0] + A[2][3] * M[3][0],
          A[2][0] * M[0][1] + A[2][1] * M[1][1] + A[2][2] * M[2][1] + A[2][3] * M[3][1],
          A[2][0] * M[0][2] + A[2][1] * M[1][2] + A[2][2] * M[2][2] + A[2][3] * M[3][2],
          A[2][0] * M[0][3] + A[2][1] * M[1][3] + A[2][2] * M[2][3] + A[2][3] * M[3][3],

          A[3][0] * M[0][0] + A[3][1] * M[1][0] + A[3][2] * M[2][0] + A[3][3] * M[3][0],
          A[3][0] * M[0][1] + A[3][1] * M[1][1] + A[3][2] * M[2][1] + A[3][3] * M[3][1],
          A[3][0] * M[0][2] + A[3][1] * M[1][2] + A[3][2] * M[2][2] + A[3][3] * M[3][2],
          A[3][0] * M[0][3] + A[3][1] * M[1][3] + A[3][2] * M[2][3] + A[3][3] * M[3][3]
        );
      } /* End of 'operator*' function */

      /* Get determ of 3x3 matrix function.
       * ARGUMENTS: 
       *   - matrix elements:
       *       Type &A11, Type &A12, Type &A13, 
       *       Type &A21, Type &A22, Type &A23, 
       *       Type &A31, Type &A32, Type &A33;
       * RETURNS: 
       *   (Type) result of operation.
       */
      Type GetDeterm3x3( Type &A11, Type &A12, Type &A13, 
                         Type &A21, Type &A22, Type &A23, 
                         Type &A31, Type &A32, Type &A33 ) const
      {
        return (A11 * A22 * A33 - 
                A11 * A23 * A32 -
                A12 * A21 * A33 + 
                A12 * A23 * A31 + 
                A13 * A21 * A32 - 
                A13 * A22 * A31);
      } /* End of 'GetDeterm3x3' function */

      /* Get determ of 4x4 matrix function.
       * ARGUMENTS: None.
       * RETURNS: 
       *   (Type) result of operation.
       */
      Type operator!( VOID ) const
      {
        return A[0][0] * GetDeterm3x3(A[1][1], A[1][2], A[1][3], A[2][1], A[2][2], A[2][3], A[3][1], A[3][2], A[3][3]) - 
               A[0][1] * GetDeterm3x3(A[1][0], A[1][2], A[1][3], A[2][0], A[2][2], A[2][3], A[3][0], A[3][2], A[3][3]) +
               A[0][2] * GetDeterm3x3(A[1][0], A[1][1], A[1][3], A[2][0], A[2][1], A[2][3], A[3][0], A[3][1], A[3][3])- - 
               A[0][3] * GetDeterm3x3(A[1][0], A[1][1], A[1][2], A[2][0], A[2][1], A[2][2], A[3][0], A[3][1], A[3][2]);
      } /* End of 'operator!' function */

      /*** FUNCTIONS ***/

      /* Get identity matrix function.
       * ARGUMENTS: None.
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr Identity( VOID ) const
      {
        return matr(1, 0, 0, 0, 
                    0, 1, 0, 0, 
                    0, 0, 1, 0,
                    0, 0, 0, 1);
      } /* End of 'Identity' function */
      
      /* Get inverse matrix function.
       * ARGUMENTS: None.
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr Inverse( VOID ) const
      {
        Type det = !*this;
        matr M;

        if (det == 0)
          return Identity();

        /* Build adjoint matrix */
        M.A[0][0] =
          +MatrDeterm3x3(A[1][1], A[1][2], A[1][3],
                         A[2][1], A[2][2], A[2][3],
                         A[3][1], A[3][2], A[3][3]) / det;
        
        M.A[1][0] =
          -MatrDeterm3x3(A[1][0], A[1][2], A[1][3],
                         A[2][0], A[2][2], A[2][3],
                         A[3][0], A[3][2], A[3][3]) / det;
        
        M.A[2][0] =
          +MatrDeterm3x3(A[1][0], A[1][1], A[1][3],
                         A[2][0], A[2][1], A[2][3],
                         A[3][0], A[3][1], A[3][3]) / det;
        
        M.A[3][0] =
          -MatrDeterm3x3(A[1][0], A[1][1], A[1][2],
                         A[2][0], A[2][1], A[2][2],
                         A[3][0], A[3][1], A[3][2]) / det;
        
        M.A[0][1] =
          -MatrDeterm3x3(A[0][1], A[0][2], A[0][3],
                         A[2][1], A[2][2], A[2][3],
                         A[3][1], A[3][2], A[3][3]) / det;
        
        M.A[1][1] =
          +MatrDeterm3x3(A[0][0], A[0][2], A[0][3],
                         A[2][0], A[2][2], A[2][3],
                         A[3][0], A[3][2], A[3][3]) / det;
        
        M.A[2][1] =
          -MatrDeterm3x3(A[0][0], A[0][1], A[0][3],
                         A[2][0], A[2][1], A[2][3],
                         A[3][0], A[3][1], A[3][3]) / det;
        
        M.A[3][1] =
          +MatrDeterm3x3(A[0][0], A[0][1], A[0][2],
                         A[2][0], A[2][1], A[2][2],
                         A[3][0], A[3][1], A[3][2]) / det;
        
        M.A[0][2] =
          +MatrDeterm3x3(A[0][1], A[0][2], A[0][3],
                         A[1][1], A[1][2], A[1][3],
                         A[3][1], A[3][2], A[3][3]) / det;
        
        M.A[1][2] =
          -MatrDeterm3x3(A[0][0], A[0][2], A[0][3],
                         A[1][0], A[1][2], A[1][3],
                         A[3][0], A[3][2], A[3][3]) / det;
        
        M.A[2][2] =
          +MatrDeterm3x3(A[0][0], A[0][1], A[0][3],
                         A[1][0], A[1][1], A[1][3],
                         A[3][0], A[3][1], A[3][3]) / det;
        
        M.A[3][2] =
          -MatrDeterm3x3(A[0][0], A[0][1], A[0][2],
                         A[1][0], A[1][1], A[1][2],
                         A[3][0], A[3][1], A[3][2]) / det;
        
        M.A[0][3] =
          +MatrDeterm3x3(A[0][1], A[0][2], A[0][3],
                         A[1][1], A[1][2], A[1][3],
                         A[2][1], A[2][2], A[2][3]) / det;
        
        M.A[1][3] =
          -MatrDeterm3x3(A[0][0], A[0][2], A[0][3],
                         A[1][0], A[1][2], A[1][3],
                         A[2][0], A[2][2], A[2][3]) / det;
        
        M.A[2][3] =
          +MatrDeterm3x3(A[0][0], A[0][1], A[0][3],
                         A[1][0], A[1][1], A[1][3],
                         A[2][0], A[2][1], A[2][3]) / det;
        
        M.A[3][3] =
          -MatrDeterm3x3(A[0][0], A[0][1], A[0][2],
                         A[1][0], A[1][1], A[1][2],
                         A[2][0], A[2][1], A[2][2]) / det;
        
        return M;
      } /* End of 'Inverse' function */


      /* Get transpose matrix function.
       * ARGUMENTS: None.
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr Transpose( VOID ) const
      {
        matr M;
        
        for (int i = 0; i < 4; i++)
          for (int j = 0; j < 4; j++)
            M.A[i][j] = A[j][i];
        return M;
      } /* End of 'Transpose' function */

      /* Rotate matrix by OX function.
       * ARGUMENTS:
       *   - angle to rotate in degrees:
       *       Type AngleInDegrees;
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr RotateX( Type AngleInDegrees ) const
      {
        Type 
          AngleInRadians = Degree2Radian(AngleInDegrees),
          si = sin(AngleInRadians), co = cos(AngleInRadians);

        return matr(1, 0, 0, 0, 
                    0, co, si, 0,
                    0, -si, co, 0,
                    0, 0, 0, 1);
      } /* End of 'RotateX' function */

      /* Rotate matrix by OY function.
       * ARGUMENTS:
       *   - angle to rotate in degrees:
       *       Type AngleInDegrees;
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr RotateY( Type AngleInDegrees ) const
      {
        Type 
          AngleInRadians = Degree2Radian(AngleInDegrees),
          si = sin(AngleInRadians), co = cos(AngleInRadians);

        return matr(co, 0, -si, 0, 
                    0, 1, 0, 0,
                    si, 0, co, 0,
                    0, 0, 0, 1);
      } /* End of 'RotateY' function */

      /* Rotate matrix by OZ function.
       * ARGUMENTS:
       *   - angle to rotate in degrees:
       *       Type AngleInDegrees;
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr RotateZ( Type AngleInDegrees ) const
      {
        Type 
          AngleInRadians = Degree2Radian(AngleInDegrees),
          si = sin(AngleInRadians), co = cos(AngleInRadians);

        return matr(co, si, 0, 0, 
                    -si, co, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1);
      } /* End of 'RotateZ' function */

      /* Rotate matrix function.
       * ARGUMENTS:
       *   - angle to rotate in degrees:
       *       Type AngleInDegrees;
       *   - vector to rotate:
       *       vec3<Type> &V;
       * RETURNS: 
       *   (matr) result new matrix.
       */
      inline matr Rotate( Type AngleInDegrees, const vec3<Type> &V ) const
      {
        Type 
          AngleInRadians = Degree2Radian(AngleInDegrees),
          si = sin(AngleInRadians), co = cos(AngleInRadians);
    
        return matr(1, 0, 0, 0, 
                    0, co, si, 0,
                    0, -si, co, 0,
                    0, 0, 0, 1);
      } /* End of 'Rotate' function */

   }; /* End of 'matr' class */
} /* end of 'mth' namespace */

#endif /* __mth_matr_h_ */

/* END OF 'mth_matr.h' FILE */
